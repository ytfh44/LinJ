# LinJ 与 ContiText 规范

## 备忘录状态

本文件为草案，用规范性用语（见第 2 节）定义 **LinJ** 与 **ContiText** 的数据模型与行为语义，并给出二者的边界与映射要求。

本文件的**底线目标**：在“同一 LinJ 文档 + 同一初始主状态 + 同一外部工具响应”前提下，串行执行与采用 ContiText 的并行执行必须得到**一致的最终主状态**。任何可能导致差异的自由度必须被显式化为“实现者可选”，且不得影响上述底线。

---

## 1. 摘要

**LinJ** 定义一种声明式描述：由节点与依赖组成，描述要注入到工作循环中的行为单元及其数据/控制/资源约束。LinJ 只规定“应做什么”与“如何依赖”，不规定并发调度、挂起/恢复或子执行单元的生命周期。

**ContiText** 定义一种异步执行机制：以“续体”为基本单位，规定挂起、恢复、合流、取消、信号等待、变更提交与冲突处理等运行时行为。

边界：**LinJ 是描述层**；**ContiText 是执行层**。LinJ 可在不支持 ContiText 的环境中运行（例如串行）；ContiText 也可执行非 LinJ 的负载。两者组合时，必须遵守第 23–26 节的映射规则。

---

## 2. 约定性用语

* **必须**：绝对要求。
* **必须不**：绝对禁止。
* **应**：推荐做法；若不采用，应说明后果。
* **不应**：不推荐。
* **可以**：可选。

---

## 3. 基本概念

### 3.1 主状态

* **主状态**为一个结构化数据对象（以下简称 `主状态对象`）。
* 所有跨节点的数据传递必须通过 `主状态对象` 完成。

### 3.2 变更集

* **变更集**是对 `主状态对象` 的一组写入与删除操作（见第 9 节与第 20 节）。

### 3.3 决定性

本文件中“决定性”指：在相同输入与相同外部工具响应下，执行器的调度选择、顺序、冲突处理与最终主状态必须一致。

---

# 第一部分：LinJ 规范

## 4. LinJ 文档与可演进机制

### 4.1 顶层对象

LinJ 文档必须是单一顶层对象，至少包含：

* `linj_version`：字符串，必须存在。
* `nodes`：数组，必须存在。
* `edges`：数组，必须存在。

可选字段：

* `loops`：数组。
* `policies`：对象。
* `requirements`：对象。
* `placement`：对象或数组。

### 4.2 版本协商

`linj_version` 必须采用 `主版本.次版本` 形式（例如 `0.1`）。

* 若**主版本**不匹配：实现者**必须**拒绝运行，并产生 `ValidationError`。
* 若主版本匹配但**次版本**更高：实现者**可以**运行，但对不识别字段必须按 4.3 处理。

### 4.3 扩展命名空间

* 任何以 `x_` 前缀命名的字段为扩展字段。
* 核心实现者对扩展字段**必须**忽略且**必须不**崩溃；但**必须不**因为忽略扩展字段而改变已识别字段的语义。

---

## 5. 状态路径与读写语义

### 5.1 状态路径语法（最小集合）

本规范定义最小可移植路径语法：

* 根为 `$`。
* 使用 `.` 访问对象字段：`$.a.b`。
* 使用 `[n]` 访问数组下标：`$.arr[0]`。
* 字段名必须为非空字符串，且不得包含 `.[]`。

实现者可以扩展语法，但扩展不得改变本节定义语义。

### 5.2 读取语义

* 读取不存在路径时：返回空值。
* 本规范中**空值**等同于结构化数据中的 `null`。

### 5.3 写入语义（决定性）

对路径写入时，执行器**必须**按以下规则：

#### 5.3.1 写入对象路径 `$.a.b`

* 若中间对象缺失：**必须**创建空对象 `{}`。
* 若中间位置存在但不是对象：**必须**产生 `MappingError`。

#### 5.3.2 写入数组路径 `$.arr[n]`

* 若 `$.arr` 不存在：**必须**创建空数组 `[]`。
* 若 `$.arr` 存在但不是数组：**必须**产生 `MappingError`。
* 若下标越界：**必须**扩容并以 `null` 填充至下标位置。

> 注：数组扩容可能导致较大存储与序列化开销；若实现者施加长度或大小限制，必须通过第 10 节的策略显式化，并在诊断信息中记录触发原因与阈值。

### 5.4 删除语义（决定性）

变更集必须支持删除操作：

* 删除路径后，该路径读取结果必须为 `null`。
* 删除对象字段：若字段不存在，删除操作为无效操作且不得报错。
* 删除数组元素：

  * 若下标越界，为无效操作且不得报错。
  * 若下标有效：该位置必须被设置为 `null`（不得缩短数组长度）。

> 注：因此数组的“长度”与“有效元素数量”可能不同。

---

## 6. 节点与值引用

### 6.1 节点通用字段

每个节点对象必须包含：

* `id`：字符串，全局唯一。
* `type`：字符串，必须为以下之一：`hint`、`tool`、`join`、`gate`。

节点对象可以包含：

* `title`、`description`：字符串。
* `reads`、`writes`：数组，声明可能读取/写入的路径。
* `in_contract`、`out_contract`：对象（见第 7 节）。
* `policy`：对象（见第 10 节）。
* `rank`：数值，可选，用于决定性调度排序（见 11.3）。

决定性并发要求：

* 若运行环境启用并发（见第 15 节），实现者**必须**使用节点的 `reads/writes` 声明参与并发安全判定（见 11.5）。
* 若某节点缺失 `reads` 或 `writes` 声明，则在并发模式下该节点必须被视为“读取与写入整个主状态”，从而阻止与其它节点并发执行。

### 6.2 路径引用与常量（可判别）

在需要“路径或常量”的位置（例如 `hint.vars`、`tool.call.args`），实现者**必须**支持显式表示：

* `{ "$path": "$.x.y" }` 表示路径引用。
* `{ "$const": <任意结构化值> }` 表示常量。

兼容模式（可选）：若实现者还支持把字符串直接解释为路径，则**必须**采用如下判别规则：

* 字符串以 `$.` 开头且满足 5.1 语法 → 视为路径引用。
* 否则 → 视为常量字符串。

---

## 7. 合同（输入/输出约束）

### 7.1 最小合同语言（可移植子集）

`in_contract` 与 `out_contract` 必须采用以下最小合同对象形式（实现者可以扩展，但不得改变语义）：

* `type`：`object` / `array` / `string` / `number` / `boolean` / `null`
* `required`：字符串数组（仅当 `type=object` 时有效）
* `properties`：对象（仅当 `type=object` 时有效），键为字段名，值为子合同对象
* `items`：子合同对象（仅当 `type=array` 时有效）

### 7.2 可验证性与报告

* 若实现者无法验证扩展表达式，必须把该合同标记为“不可验证”。
* 对不可验证部分，执行器**必须不**把“验证通过”当作前提；但**可以**继续执行并在诊断信息中记录。

---

## 8. 依赖（edges）与映射（map）

### 8.1 依赖对象

每条依赖必须包含：

* `from`：源节点 `id`
* `to`：目标节点 `id`
* `kind`：`data` / `control` / `resource`

可选：

* `weight`：数值，默认 1。
* `map`：对象，仅 `kind=data` 可用。
* `resource_name`：字符串，仅 `kind=resource` 可用。

### 8.2 映射规则

当 `kind=data` 且提供 `map` 时：

* `map` 由若干条规则组成，每条规则包含：

  * `from`：路径
  * `to`：路径
  * `default`：可选，常量；当 `from` 不存在时使用
* 执行器必须在目标节点执行前应用这些规则。
* 若 `from` 不存在且无 `default`：该条规则为无效操作。

### 8.3 多入边映射冲突（决定性）

当同一目标节点存在多条入边映射，并对同一路径或相交路径写入时：

* 默认行为：执行器**必须**产生 `ConflictError`。
* 若实现者支持“决定性覆盖”，则必须按以下确定性优先级应用：

  1. `weight` 大者优先
  2. `edges` 数组中靠前者优先
  3. 若仍相同，按 `(from, to)` 字典序优先
* 采用覆盖时，执行器必须在诊断信息中记录被覆盖的规则。

---

## 9. 变更集（LinJ 视角）

### 9.1 变更集格式（最小集合）

节点执行的结果必须以变更集形式表达：

* `writes`: 数组，每项包含 `path` 与 `value`
* `deletes`: 数组，每项包含 `path`

### 9.2 原子性

* 变更集的应用必须是原子性的：要么全部生效，要么全部失败。
* 禁止部分成功。

---

## 10. 策略（policies）

### 10.1 全局策略

顶层 `policies` 可包含：

* `max_steps`：最大节点尝试执行次数（含失败与重试）。
* `max_rounds`：最大循环轮数。
* `timeout_ms`：整体超时。
* `retry`：对象，包含 `max` 与 `backoff_ms`。

实现者可以提供限制类策略以控制资源占用，但必须显式化并可诊断，例如：

* `max_array_length`：最大数组长度；超过则必须产生 `MappingError` 并记录阈值。
* `max_local_state_bytes`：续体私有状态大小上限（见 17–18 节）；超过则必须产生 `ExecutionError` 并记录阈值。

### 10.2 节点策略

节点 `policy` 可覆盖全局策略子集，并可包含：

* `allow_reenter`：布尔，是否允许同一轮内被重复触发执行（默认 false）。

---

## 11. 执行语义（LinJ 层，决定性要求）

### 11.1 成功完成判定

节点一次尝试执行被视为“成功完成”必须同时满足：

1. 未产生 `ExecutionError`；
2. 若 `out_contract` 可验证，则输出变更集应用后的相关路径满足 `out_contract`；否则产生 `ValidationError`。

### 11.2 隐式循环有界性

* 若依赖关系形成循环但未被 `loops` 覆盖：执行器**必须**使用 `policies.max_rounds` 作为上限。
* 若此时 `policies.max_rounds` 未提供：执行器**必须**拒绝运行并产生 `ValidationError`。

### 11.3 决定性调度顺序（串行与并行一致的基准）

当同一时刻存在多个“可调度节点”（其所有 `data/control` 前置依赖已满足）时：

* 执行器**必须**按如下决定性顺序分配 `step_id`（见 24.3）：

  1. `rank` 较大者优先（未提供视为 0）
  2. `nodes` 数组中靠前者优先
  3. 若仍相同，按 `node_id` 字典序

并行执行（若实现者支持）不得改变 `step_id` 的分配顺序。

### 11.4 写入相交判定（决定性）

两条写入或删除路径被视为相交，当且仅当满足以下任一条件：

* 一条路径是另一条路径的前缀（例如 `$.a` 与 `$.a.b`）。
* 两条路径完全相同。
* 对数组：

  * `$.a[0]` 与 `$.a[1]` **不相交**。
  * `$.a` 与 `$.a[1]` **相交**。
  * `$.a[0]` 与 `$.a[0].b` **相交**。

### 11.5 并发安全判定（决定性）

若运行环境启用并发，则执行器**必须**保证：

* 两个并发执行的节点，其声明的写入集合（`writes`）互不相交；
* 且任一节点的读取集合（`reads`）不得与另一节点的写入集合相交。

若无法证明上述条件（包括缺失 `reads/writes` 声明），则必须禁止这两个节点并发执行。

> 注：此要求确保并发执行时的读取等价于某个确定性的串行顺序，从而满足底线目标。

---

## 12. 循环（loops）

### 12.1 显式循环对象

每个循环对象可包含：

* `id`：字符串
* `entry`：节点 `id`
* `members`：节点 `id` 数组
* `mode`：`finite` 或 `infinite`（默认 `finite`）
* `stop_condition`：字符串（见第 14 节）
* `max_rounds`：数值

### 12.2 有限循环

* `mode=finite` 时，`stop_condition` 或 `max_rounds` 至少存在其一。
* 若两者都缺省：必须产生 `ValidationError`。

### 12.3 无限循环（可取消、不可忙等）

* `mode=infinite` 时，`stop_condition` 可以缺省。
* 运行时**必须**可取消。
* 执行器**必须不**忙等；当无可推进节点时，应挂起等待信号或输入（见 21.2）。

---

## 13. 节点类型最小语义

### 13.1 hint（提示生成节点）

必须字段：

* `template`：字符串。
* `vars`：对象，可选。每个变量值为 6.2 的“路径引用或常量”。
* `write_to`：路径，必须存在。

模板语法（最小集合）：

* 占位符形式为 `{{name}}`，其中 `name` 为由字母、数字与下划线组成的非空标识。
* 渲染规则：

  * 对每个占位符，必须在 `vars` 中提供同名变量。
  * 若变量为路径引用且路径不存在，且未提供替代常量：必须产生 `ValidationError`。
  * 替换结果为该变量值的字符串表示；若为 `null`，替换为空串。
* 默认不进行转义。

### 13.2 tool（工具调用节点）

必须字段：

* `call`：对象，包含：

  * `name`：字符串
  * `args`：对象，参数值为 6.2 的“路径引用或常量”
* `write_to`：路径，可选
* `effect`：`none` / `read` / `write`，默认 `read`
* `repeat_safe`：布尔，默认 false

重试规则（决定性）：

* 若 `effect` 为 `write` 且 `repeat_safe` 为 false：即使全局允许重试，执行器**必须不**自动重试该节点。
* 若 `effect` 为 `none` 或 `read`：可按策略重试。

输出验证：

* 若定义了 `out_contract` 且可验证，则工具返回写入 `write_to` 后必须满足；否则产生 `ValidationError`。

### 13.3 join（接合节点）

必须字段：

* `input_from`：路径
* `output_to`：路径

可选字段：

* `language`：字符串（仅作为标注；除非被合同或检查规则引用，否则不产生强制语义）
* `style`：字符串（同上）
* `glossary`：数组，每项可包含：

  * `prefer`：字符串（推荐项；除非实现者声明支持检查，否则不产生强制语义）
  * `forbid`：字符串数组（强制禁止项；见下）

强制语义（最小集合）：

* 若 `glossary[*].forbid` 存在，则输出的字符串表示**必须不**包含任一禁止项子串；否则必须产生 `ValidationError`。

### 13.4 gate（条件门控节点）

必须字段：

* `condition`：字符串（见第 14 节）
* `then`：节点 `id` 数组
* `else`：节点 `id` 数组

触发规则（决定性）：

* gate 触发仅将节点加入“可调度集合”，不得豁免其既有依赖。
* 默认去重：同一 `round` 内，同一节点即使被多次触发也不得重复执行；除非该节点 `policy.allow_reenter=true`。

---

## 14. 条件表达式（决定性）

### 14.1 语义元素

* 比较：`== != > >= < <=`
* 逻辑：`AND OR NOT`（必须短路）
* 函数：

  * `exists(path)`：路径存在且值非 `null` 为真
  * `len(path)`：数组长度；非数组或不存在则为 0
  * `value(path)`：取值，不存在则为 `null`

### 14.2 类型与空值规则

* 比较运算：

  * 若任一侧为 `null`：仅 `==` 与 `!=` 有意义；其它比较结果必须为 false。
  * 类型不匹配：必须产生 `ConditionError`。
* `len(path)` 返回数组的**物理长度**（包含尾部 `null`）。
* 逻辑运算必须短路：

  * `A AND B` 中若 `A` 为 false，则不得求值 `B`。
  * `A OR B` 中若 `A` 为 true，则不得求值 `B`。

---

## 15. requirements 与 placement

### 15.1 requirements（必须/可选）

`requirements` 的每个字段必须为布尔值：

* `true` 表示必须满足；不满足则拒绝运行并产生 `ValidationError`。
* `false` 或缺省表示不要求。

建议字段（实现者可扩展，但必须以 `x_` 前缀扩展）：

* `allow_parallel`
* `allow_child_units`
* `require_resume`

### 15.2 placement（最小语义）

placement 用于声明“绑定到同一执行域标签”。

* placement 条目可包含：

  * `target`：节点 `id` 或 `resource_name`
  * `domain`：字符串，执行域标签

语义：具有同一 `domain` 的目标应被安排在同一执行域中。运行时可以在不改变决定性语义的前提下进行域的物理迁移，但必须维持第 24.3 的 `step_id` 与提交决定性要求。

若运行时无法满足同域要求（例如无法在同一执行域内运行相关节点），且该约束被视为必须，则必须拒绝运行（见第 25 节）。

---

# 第二部分：ContiText 规范

## 16. ContiText 概览

ContiText 以“续体”为基本单位，定义：派生、挂起、恢复、合流、取消、信号等待、变更提交与冲突处理。

ContiText 不规定节点含义与依赖计算；这些由 LinJ 或其他描述层提供。

---

## 17. 续体句柄与持久化

### 17.1 句柄要求

* 每个续体必须拥有唯一 `handle`。
* `handle` 必须可序列化为字符串。

### 17.2 可解析性范围与过期

* 若实现者支持持久化，`handle` 至少在其声明的持久化周期内必须可解析。
* 过期时必须返回明确错误 `HandleExpired`（或等价错误码）。

资源约束显式化：

* 若实现者施加续体相关的存储或大小限制（例如 `local_state` 大小），必须通过第 10 节的策略或运行时诊断显式记录，使其可重现。

### 17.3 隔离与访问控制

实现者**应**提供访问控制与隔离，以避免不同运行之间的续体互相访问。若实现者提供多租户能力，则访问控制**必须**隔离不同租户。

---

## 18. 续体状态与视图

### 18.1 续体状态

每个续体具有：

* `status`：`running` / `suspended` / `completed` / `failed` / `cancelled`
* `local_state`：续体私有状态对象
* `view`：对主状态对象的受控视图

### 18.2 视图模式与逻辑快照（决定性）

视图至少支持：

* 只读视图：只能读取主状态。
* 变更视图：可产生变更集，但不得直接写入主状态。

默认视图应为变更视图。

为满足底线目标，运行时**必须**为每次节点尝试提供与其 `step_id` 对应的逻辑快照：

* 节点尝试在开始读取主状态时，其视图内容必须等价于“按决定性规则应用所有 `step_id` 小于本次尝试的、已被接受的变更集后得到的主状态”。
* 视图必须不包含任何 `step_id` 大于等于本次尝试的变更集效果。

---

## 19. 基本操作

实现者必须提供等价行为：

### 19.1 派生

* 从当前续体派生子续体，返回其 `handle`。

### 19.2 挂起

* 将续体置为 `suspended`。
* 挂起时可以产出：

  * 变更集（见第 20 节）
  * 待发送信号（见第 21 节）
  * 等待条件（见 21.2）

### 19.3 恢复

* 将 `suspended` 的续体置为 `running`。
* 恢复时可以注入输入数据。

### 19.4 合流

* 等待一个或多个续体到达终态。
* 合流返回必须包含每个续体的：`status`、`output`、`error`（若有）。

决定性要求：

* 合流仅负责汇总终态，不得直接合并多个续体对主状态的写入；主状态变更必须通过第 20 节的提交规则完成。

### 19.5 取消

* 取消请求必须幂等：重复取消不得产生新副作用。
* 取消传播：主续体被取消时，其仍存活的子续体应被取消，除非子续体被明确声明为独立。
* 取消后不得提交变更：已进入 `cancelled` 的续体**必须不**再提交变更集。

---

## 20. 变更集提交（ContiText 层，决定性）

### 20.1 变更集格式

ContiText 必须支持第 9.1 节的变更集格式：

* `writes: [{ path, value }]`
* `deletes: [{ path }]`

### 20.2 原子性边界

一次提交要么全部成功，要么全部失败；部分成功必须不发生。

### 20.3 基准修订（可选但强烈建议）

实现者可以为主状态维护 `revision`（单调递增整数或等价标识）。

* 续体提交变更时可以携带 `base_revision`。
* 若 `base_revision` 与当前不匹配：必须产生冲突错误。

---

## 21. 信号与等待

### 21.1 信号结构

信号包含：

* `name`：字符串
* `payload`：结构化数据
* `correlation`：可选字符串

### 21.2 等待条件（最小语义）

续体可以挂起并声明等待条件，最小集合必须支持：

* 按 `name` 精确匹配
* 可选按 `correlation` 精确匹配
* 可选谓词表达式：使用 LinJ 条件表达式语义（第 14 节），其中 `value("$.signal.payload")` 表示信号载荷

### 21.3 缓存与重放

* 默认行为：信号不得被重放给未来的等待者。
* 若实现者支持重放，必须显式声明并在诊断信息中记录。

---

## 22. 冲突策略与报告

### 22.1 冲突策略

实现者必须支持至少一种策略：

1. 拒绝策略：检测到相交写入则拒绝提交并产生冲突错误。
2. 决定性合并策略：按固定规则合并并记录。

### 22.2 合并可追溯性

若采用决定性合并：

* 运行时必须把合并规则与合并结果的关键元信息写入诊断信息或主状态（见第 27 节）。

---

# 第三部分：LinJ ↔ ContiText 映射

## 23. 基本映射

* 一次 LinJ 运行对应一个主续体。
* LinJ 节点尝试执行可以在主续体内执行，或派生子续体执行后合流。

---

## 24. step 与 round（决定性计数）

### 24.1 round

* `round` 为循环轮次计数。
* 若无循环：`round` 固定为 0。

### 24.2 step

* `step` 为节点**尝试执行**计数：每次尝试（含失败与重试）计一次。

### 24.3 step_id 分配与提交决定性（核心）

为满足“并行不改变最终主状态”，在采用 ContiText 的并行执行时必须满足：

* 主运行时必须按第 11.3 节的决定性顺序为每次节点尝试分配单调递增的 `step_id`。
* 所有变更集必须按下述决定性规则被接受并作用于主状态：

  * 基准规则：按 `step_id` 升序串行接受。
  * 只读优化（可选）：若某次尝试产生空变更集（`writes/deletes` 均为空），运行时可以立即记录其完成而无需等待提交顺序。
  * 非相交优化（可选）：运行时可以提前接受较大 `step_id` 的变更集，但仅当该变更集与所有尚未被接受且 `step_id` 更小的变更集在写入/删除路径集合上两两不相交（按 11.4 判定）。

无论采用何种优化，最终主状态必须等价于按 `step_id` 递增依次应用所有被接受变更集的结果。

---

## 25. 资源域约束映射

当 LinJ 依赖 `kind=resource` 或 placement 声明同域时：

* 运行时必须保证相关节点在同一执行域中。
* 若无法满足：必须拒绝运行并产生 `ValidationError`，错误码建议为 `ResourceConstraintUnsatisfied`。

---

## 26. 外部工具不可重放的诊断记录（强烈建议）

当工具调用在恢复或重试时遇到外部不可重放（例如凭证失效、外部状态已变化）导致无法满足一致性时，运行时应在主状态写入诊断信息：

* `$.diagnostics.non_replayable`：对象，至少包含 `node_id`、`tool_name`、`reason`、`at_step_id`。

---

# 附录：调试、测试与安全（建议性）

## 27. 追踪记录（强烈建议）

建议在主状态维护 `$.trace[]`，每条包含：

* `step_id`、`round`、`node_id`、`attempt`
* `status`（completed/failed/cancelled 等）
* `reads_actual`、`writes_actual`
* `ts_start_ms`、`ts_end_ms`（物理时间戳；单位毫秒）
* `error`（结构化：type/code/message/details）

> 注：为便于并发调试，实现者可以额外记录“物理并发关系”（例如同一时间窗口内并行运行的节点集合），但必须以 `x_` 前缀扩展字段提供。

## 28. 一致性测试建议（强烈建议）

建议提供一组对照用例以验证“串行与并行一致性”，至少覆盖：

* 多入边映射冲突
* gate 重复触发去重
* 隐式循环的有界性拒绝
* 写入相交与不相交判定
* `effect=write` 且 `repeat_safe=false` 的禁止自动重试
* 信号等待恢复
* 取消传播与取消后禁止提交

实现者**应**为底线目标给出可执行的形式化模型或等价的严谨推导，并以测试用例验证。

## 29. 最小权限（建议）

* `reads/writes` 不应仅为文档；运行时应尽可能强制执行最小读取集与最小写入集。
* 对具有副作用的工具调用，应要求显式 `effect` 与 `repeat_safe`，并默认禁止自动重试。
